// This is C8E6v_torus from "The Cg Tutorial" (Addison-Wesley, ISBN
// 0321194969) by Randima Fernando and Mark J. Kilgard.  See page 223.


void C8E6v_torus(float2 parametric : POSITION,
				 float3 norm	   : NORMAL,

             out float4 oPosition      : POSITION,
             out float2 oTexCoord      : TEXCOORD0,
             out float3 lightDirection : TEXCOORD1,
             out float3 halfAngle      : TEXCOORD2,
             out float3 diffuse		   : TEXCOORD3,
             out float3 specular	   : TEXCOORD4,

         uniform float3 lightPosition,  // Object-space
         uniform float3 eyePosition,    // Object-space
         uniform float4x4 modelViewProj,
         uniform float2 torusInfo,
         uniform float3	eyePositionW,
         uniform float4x4 modelToWorld,
         uniform float3	lightColor,      
         uniform float3 Kd,
         uniform float3 Ks,
         uniform float3 shininess)
{
  const float pi2 = 6.28318530;  // 2 times Pi
 
  // Stetch texture coordinates counterclockwise
  // over torus to repeat normal map in 6 by 2 pattern
  float M = torusInfo[1];
  float N = torusInfo[0];
  
  // Compute torus position from its parameteric equation
  float cosS, sinS;
  sincos(pi2 * parametric.x, sinS, cosS);
  float cosT, sinT;
  sincos(pi2 * parametric.y, sinT, cosT);
  float3 torusPosition = float3((M + N * cosT) * cosS,
                                (M + N * cosT) * sinS,
                                N * sinT);
                                
 /////////////////////////////////////////////////////////////////   
                            
  float4 position = float4(torusPosition, 1);
  
  float3 P = position.xyz;
  float3 N2 = norm;
  
  oPosition = mul(modelViewProj, position);
  oTexCoord = parametric * float2(-1, 5);
  
  // Compute the diffuse term
  float3 L = normalize(lightPosition - P);
  float diffuseLight = max(dot(N2, L), 0);
  diffuse = Kd * lightColor * diffuseLight;
  
  // Compute the specular term
  float3 V = normalize(eyePosition - P);
  float3 H = normalize(L+V);
  float specularLight = pow(max(dot(N2, H), 0), shininess);
  if(diffuseLight <= 0) specularLight = 0;
  specular = Ks * lightColor * specularLight;
  
  // Compute position and normal in world space
  float3 Pw = mul(modelToWorld, position).xyz;
  float3 Nw = mul((float3x3)modelToWorld, norm);
  Nw = normalize(Nw);
  
  // Compute the incident and reflected vectors
  float3 I = Pw - eyePositionW;
  lightDirection = reflect(I, Nw); 
 
 /////////////////////////////////////////////////////////////////
 
  // Compute per-vertex rotation matrix
  float3 dPds = float3(-sinS*(M+N*cosT), cosS*(M+N*cosT), 0);
  float3 norm_dPds = normalize(dPds);
  float3 normal = float3(cosS * cosT, sinS * cosT, sinT);
  float3 dPdt = cross(normal, norm_dPds);
  float3x3 rotation = float3x3(norm_dPds,
                               dPdt,
                               normal);
}
